/* tslint:disable */
/* eslint-disable */
/**
 * Once Upon
 * API documentation
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AbiDto,
  CollectionPriceDataDto,
  ContractCallRequestDto,
  NFTCollectionDto,
  NftsByContractResponseDto,
  OwnershipDto,
} from '../models/index';
import {
    AbiDtoFromJSON,
    AbiDtoToJSON,
    CollectionPriceDataDtoFromJSON,
    CollectionPriceDataDtoToJSON,
    ContractCallRequestDtoFromJSON,
    ContractCallRequestDtoToJSON,
    NFTCollectionDtoFromJSON,
    NFTCollectionDtoToJSON,
    NftsByContractResponseDtoFromJSON,
    NftsByContractResponseDtoToJSON,
    OwnershipDtoFromJSON,
    OwnershipDtoToJSON,
} from '../models/index';

export interface ContractsControllerCallContractRequest {
    address: string;
    chainId: number;
    contractCallRequestDto: ContractCallRequestDto;
}

export interface ContractsControllerGetAbiRequest {
    fingerprint: string;
}

export interface ContractsControllerGetContractRequest {
    address: string;
    chainId: number;
}

export interface ContractsControllerGetContractTransactionsDetailsRequest {
    address: string;
    chainId: number;
}

export interface ContractsControllerGetContractsByAddressRequest {
    address: string;
}

export interface ContractsControllerGetContractsByCodeFingerprintRequest {
    fingerprint: string;
}

export interface ContractsControllerGetContractsByCodeFingerprintAndChainRequest {
    chainId: number;
    fingerprint: string;
}

export interface ContractsControllerGetNftByTokenIdRequest {
    address: string;
    chainId: number;
    tokenId: number;
}

export interface ContractsControllerGetNftHoldersRequest {
    address: string;
    chainId: number;
}

export interface ContractsControllerGetNftsRequest {
    address: string;
    chainId: number;
    cursor?: string;
    limit?: number;
}

export interface ContractsControllerGetPriceDataRequest {
    address: string;
    chainId: number;
}

export interface ContractsControllerGetTokenHoldersRequest {
    address: string;
    chainId: number;
}

export interface ContractsControllerGetTokenPriceRequest {
    address: string;
    chainId: number;
}

/**
 * 
 */
export class ContractsApi extends runtime.BaseAPI {

    /**
     * Calls a method on a contract with specified parameters.
     * Call Contract Method
     */
    async contractsControllerCallContractRaw(requestParameters: ContractsControllerCallContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<object>>> {
        if (requestParameters['address'] == null) {
            throw new runtime.RequiredError(
                'address',
                'Required parameter "address" was null or undefined when calling contractsControllerCallContract().'
            );
        }

        if (requestParameters['chainId'] == null) {
            throw new runtime.RequiredError(
                'chainId',
                'Required parameter "chainId" was null or undefined when calling contractsControllerCallContract().'
            );
        }

        if (requestParameters['contractCallRequestDto'] == null) {
            throw new runtime.RequiredError(
                'contractCallRequestDto',
                'Required parameter "contractCallRequestDto" was null or undefined when calling contractsControllerCallContract().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/contracts/{address}/{chainId}/call`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters['address']))).replace(`{${"chainId"}}`, encodeURIComponent(String(requestParameters['chainId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ContractCallRequestDtoToJSON(requestParameters['contractCallRequestDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Calls a method on a contract with specified parameters.
     * Call Contract Method
     */
    async contractsControllerCallContract(requestParameters: ContractsControllerCallContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<object>> {
        const response = await this.contractsControllerCallContractRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches the ABI for a specific contract using its fingerprint.
     * Retrieve Contract ABI
     */
    async contractsControllerGetAbiRaw(requestParameters: ContractsControllerGetAbiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AbiDto>>> {
        if (requestParameters['fingerprint'] == null) {
            throw new runtime.RequiredError(
                'fingerprint',
                'Required parameter "fingerprint" was null or undefined when calling contractsControllerGetAbi().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/contracts/abi/{fingerprint}`.replace(`{${"fingerprint"}}`, encodeURIComponent(String(requestParameters['fingerprint']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AbiDtoFromJSON));
    }

    /**
     * Fetches the ABI for a specific contract using its fingerprint.
     * Retrieve Contract ABI
     */
    async contractsControllerGetAbi(requestParameters: ContractsControllerGetAbiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AbiDto>> {
        const response = await this.contractsControllerGetAbiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches a specific contract based on address and chain ID.
     * Retrieve Specific Contract
     */
    async contractsControllerGetContractRaw(requestParameters: ContractsControllerGetContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<object>>> {
        if (requestParameters['address'] == null) {
            throw new runtime.RequiredError(
                'address',
                'Required parameter "address" was null or undefined when calling contractsControllerGetContract().'
            );
        }

        if (requestParameters['chainId'] == null) {
            throw new runtime.RequiredError(
                'chainId',
                'Required parameter "chainId" was null or undefined when calling contractsControllerGetContract().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/contracts/{address}/{chainId}`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters['address']))).replace(`{${"chainId"}}`, encodeURIComponent(String(requestParameters['chainId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetches a specific contract based on address and chain ID.
     * Retrieve Specific Contract
     */
    async contractsControllerGetContract(requestParameters: ContractsControllerGetContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<object>> {
        const response = await this.contractsControllerGetContractRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches transaction details of a specific contract.
     * Retrieve Contract Transactions
     */
    async contractsControllerGetContractTransactionsDetailsRaw(requestParameters: ContractsControllerGetContractTransactionsDetailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<object>>> {
        if (requestParameters['address'] == null) {
            throw new runtime.RequiredError(
                'address',
                'Required parameter "address" was null or undefined when calling contractsControllerGetContractTransactionsDetails().'
            );
        }

        if (requestParameters['chainId'] == null) {
            throw new runtime.RequiredError(
                'chainId',
                'Required parameter "chainId" was null or undefined when calling contractsControllerGetContractTransactionsDetails().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/contracts/{address}/{chainId}/transactions-details`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters['address']))).replace(`{${"chainId"}}`, encodeURIComponent(String(requestParameters['chainId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetches transaction details of a specific contract.
     * Retrieve Contract Transactions
     */
    async contractsControllerGetContractTransactionsDetails(requestParameters: ContractsControllerGetContractTransactionsDetailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<object>> {
        const response = await this.contractsControllerGetContractTransactionsDetailsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches contracts associated with a given address.
     * Retrieve Contracts by Address
     */
    async contractsControllerGetContractsByAddressRaw(requestParameters: ContractsControllerGetContractsByAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<object>>> {
        if (requestParameters['address'] == null) {
            throw new runtime.RequiredError(
                'address',
                'Required parameter "address" was null or undefined when calling contractsControllerGetContractsByAddress().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/contracts/{address}`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters['address']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetches contracts associated with a given address.
     * Retrieve Contracts by Address
     */
    async contractsControllerGetContractsByAddress(requestParameters: ContractsControllerGetContractsByAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<object>> {
        const response = await this.contractsControllerGetContractsByAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches contract details based on a unique code fingerprint, providing information about the contract associated with that fingerprint.
     * Retrieve contract by fingerprint
     */
    async contractsControllerGetContractsByCodeFingerprintRaw(requestParameters: ContractsControllerGetContractsByCodeFingerprintRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['fingerprint'] == null) {
            throw new runtime.RequiredError(
                'fingerprint',
                'Required parameter "fingerprint" was null or undefined when calling contractsControllerGetContractsByCodeFingerprint().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/contracts/fingerprint/{fingerprint}`.replace(`{${"fingerprint"}}`, encodeURIComponent(String(requestParameters['fingerprint']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetches contract details based on a unique code fingerprint, providing information about the contract associated with that fingerprint.
     * Retrieve contract by fingerprint
     */
    async contractsControllerGetContractsByCodeFingerprint(requestParameters: ContractsControllerGetContractsByCodeFingerprintRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.contractsControllerGetContractsByCodeFingerprintRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches contract details based on a unique code fingerprint and chain ID, providing information about the contract associated with that fingerprint on a specific blockchain.
     * Retrieve contract by fingerprint and chain ID
     */
    async contractsControllerGetContractsByCodeFingerprintAndChainRaw(requestParameters: ContractsControllerGetContractsByCodeFingerprintAndChainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<object>>> {
        if (requestParameters['chainId'] == null) {
            throw new runtime.RequiredError(
                'chainId',
                'Required parameter "chainId" was null or undefined when calling contractsControllerGetContractsByCodeFingerprintAndChain().'
            );
        }

        if (requestParameters['fingerprint'] == null) {
            throw new runtime.RequiredError(
                'fingerprint',
                'Required parameter "fingerprint" was null or undefined when calling contractsControllerGetContractsByCodeFingerprintAndChain().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/contracts/fingerprint/{chainId}/{fingerprint}`.replace(`{${"chainId"}}`, encodeURIComponent(String(requestParameters['chainId']))).replace(`{${"fingerprint"}}`, encodeURIComponent(String(requestParameters['fingerprint']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetches contract details based on a unique code fingerprint and chain ID, providing information about the contract associated with that fingerprint on a specific blockchain.
     * Retrieve contract by fingerprint and chain ID
     */
    async contractsControllerGetContractsByCodeFingerprintAndChain(requestParameters: ContractsControllerGetContractsByCodeFingerprintAndChainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<object>> {
        const response = await this.contractsControllerGetContractsByCodeFingerprintAndChainRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches details of a specific Non-Fungible Token (NFT) based on its contract address, blockchain chain ID, and token ID.
     * Retrieve Specific NFT
     */
    async contractsControllerGetNftByTokenIdRaw(requestParameters: ContractsControllerGetNftByTokenIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NFTCollectionDto>> {
        if (requestParameters['address'] == null) {
            throw new runtime.RequiredError(
                'address',
                'Required parameter "address" was null or undefined when calling contractsControllerGetNftByTokenId().'
            );
        }

        if (requestParameters['chainId'] == null) {
            throw new runtime.RequiredError(
                'chainId',
                'Required parameter "chainId" was null or undefined when calling contractsControllerGetNftByTokenId().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling contractsControllerGetNftByTokenId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/contracts/{address}/{chainId}/nfts/{tokenId}`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters['address']))).replace(`{${"chainId"}}`, encodeURIComponent(String(requestParameters['chainId']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NFTCollectionDtoFromJSON(jsonValue));
    }

    /**
     * Fetches details of a specific Non-Fungible Token (NFT) based on its contract address, blockchain chain ID, and token ID.
     * Retrieve Specific NFT
     */
    async contractsControllerGetNftByTokenId(requestParameters: ContractsControllerGetNftByTokenIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NFTCollectionDto> {
        const response = await this.contractsControllerGetNftByTokenIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches a list of holders for a specific Non-Fungible Token (NFT) based on its contract address and the blockchain chain ID.
     * Retrieve NFT Holders
     */
    async contractsControllerGetNftHoldersRaw(requestParameters: ContractsControllerGetNftHoldersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<OwnershipDto>>> {
        if (requestParameters['address'] == null) {
            throw new runtime.RequiredError(
                'address',
                'Required parameter "address" was null or undefined when calling contractsControllerGetNftHolders().'
            );
        }

        if (requestParameters['chainId'] == null) {
            throw new runtime.RequiredError(
                'chainId',
                'Required parameter "chainId" was null or undefined when calling contractsControllerGetNftHolders().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/contracts/{address}/{chainId}/nfts/holders`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters['address']))).replace(`{${"chainId"}}`, encodeURIComponent(String(requestParameters['chainId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OwnershipDtoFromJSON));
    }

    /**
     * Fetches a list of holders for a specific Non-Fungible Token (NFT) based on its contract address and the blockchain chain ID.
     * Retrieve NFT Holders
     */
    async contractsControllerGetNftHolders(requestParameters: ContractsControllerGetNftHoldersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<OwnershipDto>> {
        const response = await this.contractsControllerGetNftHoldersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches all Non-Fungible Tokens (NFTs) associated with a specific contract address and blockchain chain ID, with optional pagination.
     * Retrieve All NFTs
     */
    async contractsControllerGetNftsRaw(requestParameters: ContractsControllerGetNftsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NftsByContractResponseDto>> {
        if (requestParameters['address'] == null) {
            throw new runtime.RequiredError(
                'address',
                'Required parameter "address" was null or undefined when calling contractsControllerGetNfts().'
            );
        }

        if (requestParameters['chainId'] == null) {
            throw new runtime.RequiredError(
                'chainId',
                'Required parameter "chainId" was null or undefined when calling contractsControllerGetNfts().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/contracts/{address}/{chainId}/nfts`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters['address']))).replace(`{${"chainId"}}`, encodeURIComponent(String(requestParameters['chainId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NftsByContractResponseDtoFromJSON(jsonValue));
    }

    /**
     * Fetches all Non-Fungible Tokens (NFTs) associated with a specific contract address and blockchain chain ID, with optional pagination.
     * Retrieve All NFTs
     */
    async contractsControllerGetNfts(requestParameters: ContractsControllerGetNftsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NftsByContractResponseDto> {
        const response = await this.contractsControllerGetNftsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches the floor price data for a specific Non-Fungible Token (NFT) collection based on its contract address and the blockchain chain ID.
     * Retrieve NFT Floor Price
     */
    async contractsControllerGetPriceDataRaw(requestParameters: ContractsControllerGetPriceDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CollectionPriceDataDto>>> {
        if (requestParameters['address'] == null) {
            throw new runtime.RequiredError(
                'address',
                'Required parameter "address" was null or undefined when calling contractsControllerGetPriceData().'
            );
        }

        if (requestParameters['chainId'] == null) {
            throw new runtime.RequiredError(
                'chainId',
                'Required parameter "chainId" was null or undefined when calling contractsControllerGetPriceData().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/contracts/{address}/{chainId}/nfts/price-data`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters['address']))).replace(`{${"chainId"}}`, encodeURIComponent(String(requestParameters['chainId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CollectionPriceDataDtoFromJSON));
    }

    /**
     * Fetches the floor price data for a specific Non-Fungible Token (NFT) collection based on its contract address and the blockchain chain ID.
     * Retrieve NFT Floor Price
     */
    async contractsControllerGetPriceData(requestParameters: ContractsControllerGetPriceDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CollectionPriceDataDto>> {
        const response = await this.contractsControllerGetPriceDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches a list of holders for a specific token based on its contract address and the blockchain chain ID.
     * Retrieve Token Holders
     */
    async contractsControllerGetTokenHoldersRaw(requestParameters: ContractsControllerGetTokenHoldersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<OwnershipDto>>> {
        if (requestParameters['address'] == null) {
            throw new runtime.RequiredError(
                'address',
                'Required parameter "address" was null or undefined when calling contractsControllerGetTokenHolders().'
            );
        }

        if (requestParameters['chainId'] == null) {
            throw new runtime.RequiredError(
                'chainId',
                'Required parameter "chainId" was null or undefined when calling contractsControllerGetTokenHolders().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/contracts/{address}/{chainId}/tokens/holders`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters['address']))).replace(`{${"chainId"}}`, encodeURIComponent(String(requestParameters['chainId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OwnershipDtoFromJSON));
    }

    /**
     * Fetches a list of holders for a specific token based on its contract address and the blockchain chain ID.
     * Retrieve Token Holders
     */
    async contractsControllerGetTokenHolders(requestParameters: ContractsControllerGetTokenHoldersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<OwnershipDto>> {
        const response = await this.contractsControllerGetTokenHoldersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches the current price of a specific token based on its contract address and the blockchain chain ID.
     * Retrieve Token Price
     */
    async contractsControllerGetTokenPriceRaw(requestParameters: ContractsControllerGetTokenPriceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['address'] == null) {
            throw new runtime.RequiredError(
                'address',
                'Required parameter "address" was null or undefined when calling contractsControllerGetTokenPrice().'
            );
        }

        if (requestParameters['chainId'] == null) {
            throw new runtime.RequiredError(
                'chainId',
                'Required parameter "chainId" was null or undefined when calling contractsControllerGetTokenPrice().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/contracts/{address}/{chainId}/tokens/price`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters['address']))).replace(`{${"chainId"}}`, encodeURIComponent(String(requestParameters['chainId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Fetches the current price of a specific token based on its contract address and the blockchain chain ID.
     * Retrieve Token Price
     */
    async contractsControllerGetTokenPrice(requestParameters: ContractsControllerGetTokenPriceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.contractsControllerGetTokenPriceRaw(requestParameters, initOverrides);
    }

}
